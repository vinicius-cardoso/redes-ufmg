Trabalho prático 3: RPCtalk - uma sala de bate-papo implementada com gRPC
--------------------------------------------------------------------------------
Objetivo:
--------------------------------------------------------------------------------

O objetivo deste trabalho é implementar um sistema simples de troca de 
mensagens de bate-papo utilizando chamadas de procedimentos remotos (RPC).
Para isso, os alunos deverão utilizar o framework gRPC, um dos mais adotados 
para esse fim, usando a linguagem Python. Um bom ponto para começar é a página 
https://grpc.io/docs/languages/python/quickstart/ e o tutorial em 
https://grpc.io/docs/languages/python/basics/.

--------------------------------------------------------------------------------
Os programas:
--------------------------------------------------------------------------------

Três programas devem ser desenvolvidos: 
- um programa servidor que será responsável pelo controle da troca de mensagens 
na sala de bate-papo, 
- um programa exibidor para mostrar as mensagens recebidas e 
- um programa leitor de teclado para envio de mensagens.

Em um sistema profissional os programas exibidores e emissores poderiam ser 
construídos como um único programa que integrasse as funções de leitura de 
teclado, exibição na tela e comunicação na rede. No nosso caso, dois programa 
separados simplificarão sensivelmente o trabalho de implementação.

--------------------------------------------------------------------------------
O servidor de bate-papo:
--------------------------------------------------------------------------------

O programa responsável por controlar a troca de mensagens deverá ser executado 
como um servidor de RPC tradicional (exceto quando ele precisar interagir com 
os programas exibidores), como será detalhado a seguir:

O código deve estar contido em um arquivo denominado sala.py e deve receber 
como parâmetro de linha de comando apenas o número do porto onde ele deve se 
conectar. A interface de RPCs implementada por esse servidor deve ser descrita 
no arquivo sala.porto e deve conter os seguintes métodos:
- registra_entrada(char id[16]) - registra com o servidor um programa de envio 
de mensagens identificado pelo string id, retornando -1 se já existir um 
programa de envio com aquele identificador, ou o número de programas daquele 
tipo registrados até aquele momento (incluindo o programa que está se 
registrando);
- registra_saida(char id[16], char fqdn[256], short int port) - registra com o 
servidor um programa exibidor identificado pelo string id, guardando o nome do 
host (fqdn) e o número do porto onde aquele exibidor pode ser contactado, 
retornando -1 se já existir um programa exibidor (com aquele identificador), ou 
o número de programas exibidores registrados até aquele momento (incluindo o 
programa que está se registrando);
- lista() - retorna uma lista com os identificadores e tipos de todos os 
programas registrados no servidor até aquele momento;
- finaliza_registro() - remove o registro do programa que chama o método e, se 
existe um exibidor com o mesmo identificador. Ele também remove seu registro e 
faz uma chamada para o método termina() daquele programa, retornando 1 se havia 
um exibidor, ou 0 caso contrário;
- termina() - termina a execução do servidor, chamando primeiro o método 
termina() de todos os programas de exibição registrados (não executa nenhuma 
função nos programas de envio);
- envia(char msg[128],char destino[16]) - se o destino for igual a "todos", 
envia a mensagem msg para todo programa exibidor registrado; caso contrário, 
envia apenas para o exibidor com nome igual a destino, retornando o número de 
vezes que a mensagem foi enviada (0 indica que o nome do identificador não foi 
encontrado).

O processo de terminar um servidor a partir de uma chamada de procedimento tem 
um detalhe: é preciso terminar o processamento do procedimento chamado primeiro 
e responder ao cliente, antes de concluir a execução. Mais detalhes sobre isso 
serão fornecidos à frente.

--------------------------------------------------------------------------------
O cliente de envio de mensagens:
--------------------------------------------------------------------------------

Esse programa implementa a parte da interface do usuário que lê mensagens da 
entrada padrão (stdin) e as envia para o servidor de bate-papo. Para isso, 
basta que o cliente leia e processe linhas da entrada padrão e acione os 
métodos do servidor de bate-papo usando a interface de RPCs definidas por ele. 

O programa deve estar contido em um arquivo denominado envia.py e deve receber 
como parâmetros o identificador do cliente (string de até 16 caracteres), o 
nome do host e o número do porto onde executa o servidor de bate-papo. Depois 
da sua inicialização, o programa deve se registrar no servidor usando o método 
registra_entrada(), escrever na saída o valor retornado pelo servidor e passar 
a ler e interpretar comandos das linhas da entrada, segundo o seguinte formato:
- M,destino,mensagem - aciona o método de envia() do servidor de bate-papo 
indicando o destino e uma string de mensagem e escreve na saída o valor 
retornado;
- L - consulta o servidor pela lista de programas registrados no servidor, 
escrevendo de volta uma lista com tipos e nomes dos programas registrados;
- F - termina a operação do programa de envio e de qualquer programa de 
exibição que tenha o mesmo identificador;
- T - termina a operação do servidor, terminando também todos os programas de 
exibição registrados (não precisa fazer nada sobre os programas de envio).

Linhas que não sigam nenhum desses padrões devem ser simplesmente ignoradas, 
sem gerar qualquer mensagem.

--------------------------------------------------------------------------------
O servidor de exibição:
--------------------------------------------------------------------------------

O programa responsável por exibir as mensagens na saída padrão executa como um 
servidor de RPC tradicional, exceto quando for preciso se registrar com o 
servidor da sala. O código deve estar contido em um arquivo denominado exibe.py 
e deve receber como parâmetros o identificador do cliente (string de até 16 
caracteres), o número do porto onde o exibidor vai esperar por comandos, o nome 
do host e o número do porto onde executa o servidor de bate-papo. Depois da sua 
inicialização, o programa deve se registrar no servidor de bate-papo usando seu 
método registra_saida(), fornecendo seu endereço e porto, escrever na saída o 
valor retornado pelo servidor e passar a processar comandos da sua interface de 
RPCs, definida no arquivo exibe.porto, que deve conter os seguintes métodos:
- exibe(char msg[128], char origem[16]) - escreve na saída a mensagem, usando o 
formato: 'Mensagem de {origem}: {msg}', retornando sempre zero;
- termina() - retorna 0 e causa o fim da execução do programa, sem exibir 
nenhuma mensagem.

Nesse caso, vale a mesma observação feita para o servidor da sala: terminar a 
execução por um procedimento remoto exige cuidados especiais!

--------------------------------------------------------------------------------
Requisitos não funcionais:
--------------------------------------------------------------------------------

O código deve usar apenas Python 3, sem bibliotecas além das consideradas 
“padrão”. Não serão aceitas outras bibliotecas, nem o uso de recursos como E/S 
assíncrona em Python. A ideia é que os programas sejam simples, mesmo. O código 
deve observar exatamente o formato de saída descrito, para garantir a correção 
automática. Programas que funcionem mas produzam saída fora do esperado serão 
penalizados.

O material desenvolvido por você deve executar sem erros nas máquinas linux do 
laboratório de graduação. (Nelas, o comando para disparar o Python é python3). 
A correção será feita naquelas máquinas: Programas que não executarem, não 
seguirem as determinações quanto a nomes, parâmetros de entrada e formato da 
saída, ou apresentarem erros durante a execução serão desconsiderados.

--------------------------------------------------------------------------------

Observações/lembretes:
- Os programas devem escrever na saída apenas os valores indicados no enunciado.
- Os servidores de sala de bate-papo não devem escrever nada na saída. Se forem 
usadas mensagens de depuração durante o desenvolvimento, elas devem ser 
removidas na versão entregue.
- Os comandos nunca serão executados com formato/parâmetros errados.
- Linhas que iniciem com letras que não definem comandos devem ser ignoradas.
- Nenhum caso de teste tentará acessar um servidor que tenha sido terminado 
anteriormente no mesmo teste - isto é, não é preciso testar se um servidor está 
ativo antes de tentar contactá-lo, nem se preocupar em lidar com erros desse 
tipo.
- Um servidor de diretórios independente pode se registrar em mais de um 
servidor de integração e um servidor de integração pode receber o registro de 
mais de um servidor de diretórios.

--------------------------------------------------------------------------------
Referências úteis:
--------------------------------------------------------------------------------

Em um primeiro uso de gRPC, pode ser que vocês encontrem diversos pontos que 
vão exigir um pouco mais de atenção no estudo da documentação para conseguir 
fazer a implementação correta. 

Consideramos que os pontos que podem dar mais trabalho e que merecem algumas 
dicas são os seguintes:
- Como identificar a máquina em que um programa está executando ?

Usualmente, cada máquina operando em rede deve ter um nome pelo qual ela pode 
ser identificada. Nesse exercício, o servidor de sala de bate-papo, ao 
registrar um servidor de sala de bate-papo deve enviar a esse último o 
seu nome, como um dos parâmetros da RPC utilizada. Esse nome pode ser obtido 
pelo processo que executa o servidor de diretório usando a função getfqdn() 
(fpdn = fully qualified domain name, ou o nome completo da máquina no domínio 
de rede onde ela opera). 

Assim, antes de iniciar o processamento de mensagens a serem exibidas, o 
servidor de exibição deve usar aquela função para obter seu nome, que será 
comunicado pela chamada do procedimento de registro no servidor de sala de 
bate-papo. Esse link ilustra como usar a função getfqdn().

- Manipulação de listas em uma chamada de procedimento:

Cada framework de RPC tem sua forma de lidar com isso. Em Sun RPC/XDR, listas 
eram representadas como vetores e deviam vir acompanhadas de um outro campo de 
parâmetro que indicaria quantas posições realmente seriam usadas no vetor. Em 
gRPC isso é relativamente mais simples, especialmente em Python: a definição do 
parâmetro usa a palavra chave repeated e ele é manipulado exatamente como uma 
lista. Esse link explica como a lista pode ser manipulada no cliente e no 
servidor (em Python).

- Desligar um servidor através de um RPC:

Como mencionado anteriormente, fazer um servidor de RPC parar de funcionar 
usando uma chamada de procedimento dele mesmo tem uma pegadinha: não basta 
chamar um exit() enquanto se executa o código do procedimento, ou ele vai 
terminar a execução antes de retornar da chamada, deixando o cliente sem 
resposta. E normalmente só se pode escrever código dentro das chamadas, já que 
não devemos alterar o código do stub. Cada framework de RPC tem uma solução 
diferente para esse problema e a solução do gRPC é bastante elegante, exigindo 
pouco código. Usa-se a geração de um evento dentro do código da RPC, que é 
capturado pelo servidor. Pode parecer complicado, mas o código para se fazer 
isso já está descrito no stackexchange.

--------------------------------------------------------------------------------
O que deve ser entregue:
--------------------------------------------------------------------------------

Cada aluno ou dupla deve entregar apenas os arquivos indicados neste enunciado,
com os nomes:
- sala.py - implementação do servidor de bate-papo
- envia.py - implementação do cliente que lê mensagens do teclado
- exibe.py - implementação do servidor de exibição de mensagens
- sala.proto - definição da interface do servidor sala.py
- exibe.proto - definição da interface do servidor exibe.py

--------------------------------------------------------------------------------